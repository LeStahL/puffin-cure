/* Generated with shader-compressor by NR4/Team210. */
#ifndef SFX_H
#define SFX_H
const char * sfx_frag =
"/* \n"
" *  Puffin Cure by Team210 - 64k Demo at Under Construction 2k18\n"
" * \n"
" *  Copyright (C) 2017  QM <TODO>\n"
" *\n"
" *  This program is free software; you can redistribute it and/or\n"
" *  modify it under the terms of the GNU General Public License\n"
" *  as published by the Free Software Foundation; either version 2\n"
" *  of the License, or (at your option) any later version.\n"
" *\n"
" *  This program is distributed in the hope that it will be useful,\n"
" *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" *  GNU General Public License for more details.\n"
" *\n"
" *  You should have received a copy of the GNU General Public License\n"
" *  along with this program; if not, write to the Free Software\n"
" *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
" */\n"
" \n"
"#version 330\n"
"\n"
"precision highp float;\n"
"\n"
"uniform float iBlockOffset;\n"
"uniform float iSampleRate;\n"
"uniform float iVolume;\n"
"\n"
"#define PI radians(180.)\n"
"float clip(float a) { return clamp(a,-1.,1.); }\n"
"float theta(float x) { return smoothstep(0., 0.01, x); }\n"
"float _sin(float a) { return sin(2. * PI * mod(a,1.)); }\n"
"float _sin(float a, float p) { return sin(2. * PI * mod(a,1.) + p); }\n"
"float _sq(float a) { return sign(2.*fract(a) - 1.); }\n"
"float _sq(float a,float pwm) { return sign(2.*fract(a) - 1. + pwm); }\n"
"float _psq(float a) { return clip(50.*_sin(a)); }\n"
"float _psq(float a, float pwm) { return clip(50.*(_sin(a) - pwm)); } \n"
"float _tri(float a) { return (4.*abs(fract(a)-.5) - 1.); }\n"
"float _saw(float a) { return (2.*fract(a) - 1.); }\n"
"float quant(float a,float div,float invdiv) { return floor(div*a+.5)*invdiv; }\n"
"float freqC1(float note){ return 32.7 * pow(2.,note/12.); }\n"
"float minus1hochN(int n) { return (1. - 2.*float(n % 2)); }\n"
"float minus1hochNminus1halbe(int n) { return round(sin(.5*PI*float(n))); }\n"
"float pseudorandom(float x) { return fract(sin(dot(vec2(x),vec2(12.9898,78.233))) * 43758.5453); }\n"
"\n"
"#define pat4(a,b,c,d,x) mod(x,1.)<.25 ? a : mod(x,1.)<.5 ? b : mod(x,1.) < .75 ? c : d\n"
"\n"
"const float BPM = 63.;\n"
"const float BPS = BPM/60.;\n"
"const float SPB = 60./BPM;\n"
"\n"
"const float Fsample = 44100.; // I think?\n"
"const float Tsample = 1./Fsample;\n"
"\n"
"const float filterthreshold = 1e-3;\n"
"\n"
"float doubleslope(float t, float a, float d, float s)\n"
"{\n"
"    return smoothstep(-.00001,a,t) - (1.-s) * smoothstep(0.,d,t-a);\n"
"}\n"
"\n"
"\n"
"float env_ADSR(float x, float L, float A, float D, float S, float R)\n"
"{\n"
"    float att = x/A;\n"
"    float dec = 1. - (1.-S)*(x-A)/D;\n"
"    float rel = (x <= L-R) ? 1. : (L-x)/R;\n"
"    return x<A ? att : x<A+D ? dec : x<= L-R ? S : x<=L ? (L-x)/R : 0.;\n"
"}\n"
"\n"
"\n"
"float s_atan(float a) { return 2./PI * atan(a); }\n"
"float squarey(float a, float edge) { return abs(a) < edge ? a : floor(4.*a+.5)*.25; } \n"
"\n"
"float supershape(float s, float amt, float A, float B, float C, float D, float E)\n"
"{\n"
"    float w;\n"
"    float m = sign(s);\n"
"    s = abs(s);\n"
"\n"
"    if(s<A) w = B * smoothstep(0.,A,s);\n"
"    else if(s<C) w = C + (B-C) * smoothstep(C,A,s);\n"
"    else if(s<=D) w = s;\n"
"    else if(s<=1.)\n"
"    {\n"
"        float _s = (s-D)/(1.-D);\n"
"        w = D + (E-D) * (1.5*_s*(1.-.33*_s*_s));\n"
"    }\n"
"    else return 1.;\n"
"    \n"
"    return m*mix(s,w,amt);\n"
"}\n"
"\n"
"\n"
"float comp_SAW(int N, float inv_N) {return inv_N * minus1hochN(N);}\n"
"float comp_TRI(int N, float inv_N) {return N % 2 == 0 ? 0. : inv_N * inv_N * minus1hochNminus1halbe(N);}\n"
"float comp_SQU(int N, float inv_N, float PW) {return N % 2 == 0 ? 0. : inv_N * (1. - minus1hochNminus1halbe(N))*_sin(PW);}\n"
"float comp_HAE(int N, float inv_N, float PW) {return N % 2 == 0 ? 0. : inv_N * (minus1hochN(N)*_sin(PW*float(N)+.25) - 1.);}\n"
"\n"
"float MACESQ(float t, float f, float phase, int NMAX, int NINC, float MIX, float CO, float NDECAY, float RES, float RES_Q, float DET, float PW, int keyF)\n"
"{\n"
"    float ret = 0.;\n"
"    float INR = keyF==1 ? 1./CO : f/CO;\n"
"    float IRESQ = keyF==1 ? 1./RES_Q : 1./(RES_Q*f);\n"
"    \n"
"    float p = f*t + phase;\n"
"    for(int N=1; N<=NMAX; N+=NINC)\n"
"    {\n"
"        float float_N = float(N);\n"
"        float inv_N = 1./float_N;\n"
"        float comp_mix = MIX < 0. ? (MIX+1.) * comp_TRI(N,inv_N)    +  (-MIX)  * comp_SAW(N,inv_N)\n"
"                       : MIX < 1. ?   MIX    * comp_TRI(N,inv_N)    + (1.-MIX) * comp_SQU(N,inv_N,PW)\n"
"                                  : (MIX-1.) * comp_HAE(N,inv_N,PW) + (2.-MIX) * comp_SQU(N,inv_N,PW);\n"
"\n"
"        float filter_N = pow(1. + pow(float_N*INR,NDECAY),-.5) + RES * exp(-pow((float_N*f-CO)*IRESQ,2.));\n"
"        \n"
"        if(abs(filter_N*comp_mix) < 1e-6) break; //or is it wise to break already?\n"
"        \n"
"        ret += comp_mix * filter_N * (_sin(float_N * p) + _sin(float_N * p * (1.+DET)));\n"
"    }\n"
"    return s_atan(ret);\n"
"}\n"
"\n"
"float reverbFsaw3_IIR(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4)\n"
"{\n"
"    int imax = int(log(filterthreshold)/log(IIRgain));\n"
"    float delay[4] = float[4](IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"    \n"
"    float sum = 0.;\n"
"    \n"
"    // 4 IIR comb filters\n"
"    for(int d=0; d<8; d++)\n"
"    {\n"
"        float fac = 1.;\n"
"        \n"
"        for(int i=0; i<imax; i++)\n"
"        {\n"
"            float _TIME = time - float(i)*delay[d] * (.8 + .4*pseudorandom(sum));\n"
"            sum += fac*(theta(_TIME*SPB)*exp(-8.*_TIME*SPB)*((.5+(.5*_psq(8.*_TIME*SPB,0.)))*(2.*fract(f*_TIME+0.)-1.)));\n"
"            fac *= -IIRgain;\n"
"        }\n"
"    }\n"
"    return .25*sum;\n"
"}\n"
"\n"
"float reverbFsaw3_AP1(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4, float APgain, float APdel1)\n"
"{\n"
"    // first allpass delay line\n"
"    float _TIME = time;\n"
"    float sum = -APgain * reverbFsaw3_IIR(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"    float fac = 1. - APgain * APgain;\n"
"    \n"
"    int imax = 1 + int((log(filterthreshold)-log(fac))/log(APgain));\n"
"    \n"
"    for(int i=0; i<imax; i++)\n"
"    {\n"
"        _TIME -= APdel1 * (.9 + 0.2*pseudorandom(time));\n"
"        sum += fac * reverbFsaw3_IIR(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"        fac *= APgain * (1. + 0.01*pseudorandom(_TIME));\n"
"    }\n"
"    return sum;        \n"
"}\n"
"\n"
"float reverbFsaw3(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4, float APgain, float APdel1, float APdel2)\n"
"{   // // based on this Schroeder Reverb from Paul Wittschen: http://www.paulwittschen.com/files/schroeder_paper.pdf\n"
"    // todo: add some noise...\n"
"    // second allpass delay line\n"
"    float _TIME = time;\n"
"    float sum = -APgain * reverbFsaw3_AP1(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4, APgain, APdel1);\n"
"    float fac = 1. - APgain * APgain;\n"
"\n"
"    int imax = 1 + int((log(filterthreshold)-log(fac))/log(APgain));\n"
"\n"
"    for(int i=0; i<imax; i++)\n"
"    {\n"
"        _TIME -= APdel2 * (.9 + 0.2*pseudorandom(time));\n"
"        sum += fac * reverbFsaw3_AP1(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4, APgain, APdel1);\n"
"        fac *= APgain * (1. + 0.01*pseudorandom(_TIME));\n"
"    }\n"
"    return sum;        \n"
"}\n"
"float reverbsnrrev_IIR(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4)\n"
"{\n"
"    int imax = int(log(filterthreshold)/log(IIRgain));\n"
"    float delay[4] = float[4](IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"    \n"
"    float sum = 0.;\n"
"    \n"
"    // 4 IIR comb filters\n"
"    for(int d=0; d<8; d++)\n"
"    {\n"
"        float fac = 1.;\n"
"        \n"
"        for(int i=0; i<imax; i++)\n"
"        {\n"
"            float _TIME = time - float(i)*delay[d] * (.8 + .4*pseudorandom(sum));\n"
"            sum += fac*clamp(1.6*_tri(_TIME*(350.+(6000.-800.)*smoothstep(-.01,0.,-_TIME)+(800.-350.)*smoothstep(-.01-.01,-.01,-_TIME)))*smoothstep(-.1,-.01-.01,-_TIME) + .7*fract(sin(_TIME*90.)*4.5e4)*doubleslope(_TIME,.05,.3,.3),-1., 1.)*doubleslope(_TIME,0.,.25,.3);\n"
"            fac *= -IIRgain;\n"
"        }\n"
"    }\n"
"    return .25*sum;\n"
"}\n"
"\n"
"float reverbsnrrev_AP1(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4, float APgain, float APdel1)\n"
"{\n"
"    // first allpass delay line\n"
"    float _TIME = time;\n"
"    float sum = -APgain * reverbsnrrev_IIR(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"    float fac = 1. - APgain * APgain;\n"
"    \n"
"    int imax = 1 + int((log(filterthreshold)-log(fac))/log(APgain));\n"
"    \n"
"    for(int i=0; i<imax; i++)\n"
"    {\n"
"        _TIME -= APdel1 * (.9 + 0.2*pseudorandom(time));\n"
"        sum += fac * reverbsnrrev_IIR(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4);\n"
"        fac *= APgain * (1. + 0.01*pseudorandom(_TIME));\n"
"    }\n"
"    return sum;        \n"
"}\n"
"\n"
"float reverbsnrrev(float time, float f, float tL, float IIRgain, float IIRdel1, float IIRdel2, float IIRdel3, float IIRdel4, float APgain, float APdel1, float APdel2)\n"
"{   // // based on this Schroeder Reverb from Paul Wittschen: http://www.paulwittschen.com/files/schroeder_paper.pdf\n"
"    // todo: add some noise...\n"
"    // second allpass delay line\n"
"    float _TIME = time;\n"
"    float sum = -APgain * reverbsnrrev_AP1(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4, APgain, APdel1);\n"
"    float fac = 1. - APgain * APgain;\n"
"\n"
"    int imax = 1 + int((log(filterthreshold)-log(fac))/log(APgain));\n"
"\n"
"    for(int i=0; i<imax; i++)\n"
"    {\n"
"        _TIME -= APdel2 * (.9 + 0.2*pseudorandom(time));\n"
"        sum += fac * reverbsnrrev_AP1(_TIME, f, tL, IIRgain, IIRdel1, IIRdel2, IIRdel3, IIRdel4, APgain, APdel1);\n"
"        fac *= APgain * (1. + 0.01*pseudorandom(_TIME));\n"
"    }\n"
"    return sum;        \n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"float AMAYSYN(float t, float B, float Bon, float Boff, float note, int Bsyn, float Brel)\n"
"{\n"
"    float Bprog = B-Bon;\n"
"    float Bproc = Bprog/(Boff-Bon);\n"
"    float L = Boff-Bon;\n"
"    float tL = SPB*L;\n"
"    float _t = SPB*(B-Bon);\n"
"    float f = freqC1(note);\n"
"    float vel = 1.; //implement later\n"
"\n"
"    float env = theta(B-Bon) * (1. - smoothstep(Boff, Boff+Brel, B));\n"
"    float s = _sin(t*f);\n"
"\n"
"    if(Bsyn == 0){}\n"
"    else if(Bsyn == 6){\n"
"      s = reverbFsaw3(_t,f,tL,.1,.00297,.00371,.00411,.00437,.3,.00017,.0005);env = theta(B-Bon)*pow(1.-smoothstep(Boff, Boff+Brel, B),.005);}\n"
"    \n"
"    else if(Bsyn == -2){\n"
"      s = 3.*s_atan(vel*smoothstep(0.,.015,_t)*smoothstep(.1+.15,.15,_t)*MACESQ(_t,(50.+(200.-50.)*smoothstep(-.12, 0.,-_t)),5.,10,1,.8,1.,1.,1.,.1,.1,0.,1) + .4*.5*step(_t,.03)*_sin(_t*1100.*1.*_saw(_t*800.*1.)) + .4*(1.-exp(-1000.*_t))*exp(-40.*_t)*_sin((400.-200.*_t)*_t*_sin(1.*(50.+(200.-50.)*smoothstep(-.12, 0.,-_t))*_t)));}\n"
"    else if(Bsyn == -6){\n"
"      s = .4*(.6+(.25*_psq(4.*B,0.)))*vel*fract(sin(t*100.*.3)*50000.*2.)*doubleslope(_t,0.,.05,0.);}\n"
"    else if(Bsyn == -7){\n"
"      s = vel*clamp(1.6*_tri(_t*(350.+(6000.-800.)*smoothstep(-.01,0.,-_t)+(800.-350.)*smoothstep(-.01-.01,-.01,-_t)))*smoothstep(-.1,-.01-.01,-_t) + .7*fract(sin(_t*90.)*4.5e4)*doubleslope(_t,.05,.3,.3),-1., 1.)*doubleslope(_t,0.,.25,.3);}\n"
"    else if(Bsyn == -8){\n"
"      s = reverbsnrrev(_t,f,tL,.15,.000297,.000371,.000411,.000437,.2,1.7e-05,5e-05);}\n"
"    \n"
"    return clamp(env,0.,1.) * s_atan(s);\n"
"}\n"
"\n"
"\n"
"float mainSynth(float time)\n"
"{\n"
"    int NO_trks = 3;\n"
"    int trk_sep[4] = int[4](0,7,15,17);\n"
"    int trk_syn[3] = int[3](6,23,23);\n"
"    float trk_norm[3] = float[3](.7,1.,1.);\n"
"    float trk_rel[3] = float[3](1.3,1.,1.);\n"
"    float mod_on[17] = float[17](4.,8.,12.,16.,20.,24.,28.,16.,18.,20.,22.,24.,26.,28.,30.,0.,2.);\n"
"    float mod_off[17] = float[17](8.,12.,16.,20.,24.,28.,32.,18.,20.,22.,24.,26.,28.,30.,32.,2.,4.);\n"
"    int mod_ptn[17] = int[17](0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2);\n"
"    float mod_transp[17] = float[17](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n"
"    float max_mod_off = 34.;\n"
"    int drum_index = 23;\n"
"    float drum_synths = 9.;\n"
"    int NO_ptns = 3;\n"
"    int ptn_sep[4] = int[4](0,32,36,40);\n"
"    float note_on[40] = float[40](0.,.125,.25,.375,.5,.625,.75,.875,1.,1.125,1.25,1.375,1.5,1.625,1.75,1.875,2.,2.125,2.25,2.375,2.5,2.625,2.75,2.875,3.,3.125,3.25,3.375,3.5,3.625,3.75,3.875,0.,.5,1.,1.5,0.,.5,1.25,1.75);\n"
"    float note_off[40] = float[40](.125,.25,.375,.5,.625,.75,.875,1.,1.125,1.25,1.375,1.5,1.625,1.75,1.875,2.,2.125,2.25,2.375,2.5,2.625,2.75,2.875,3.,3.125,3.25,3.375,3.5,3.625,3.75,3.875,4.,.5,1.,1.5,2.,.125,1.25,2.,2.);\n"
"    float note_pitch[40] = float[40](17.,22.,24.,29.,31.,36.,38.,43.,48.,46.,41.,36.,33.,29.,44.,39.,36.,32.,41.,36.,32.,29.,26.,22.,41.,38.,34.,32.,37.,34.,31.,27.,2.,2.,2.,2.,6.,8.,7.,8.);\n"
"    float note_vel[40] = float[40](1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.);\n"
"    \n"
"    float r = 0.;\n"
"    float d = 0.;\n"
"\n"
"    // mod for looping\n"
"    float BT = mod(BPS * time, max_mod_off);\n"
"    if(BT > max_mod_off) return r;\n"
"    time = SPB * BT;\n"
"\n"
"    float r_sidechain = 1.;\n"
"\n"
"    float Bon = 0.;\n"
"    float Boff = 0.;\n"
"\n"
"    for(int trk = 0; trk < NO_trks; trk++)\n"
"    {\n"
"        int TLEN = trk_sep[trk+1] - trk_sep[trk];\n"
"\n"
"        int _modU = TLEN-1;\n"
"        for(int i=0; i<TLEN-1; i++) if(BT < mod_on[(trk_sep[trk]+i)]) {_modU = i; break;}\n"
"               \n"
"        int _modL = TLEN-1;\n"
"        for(int i=0; i<TLEN-1; i++) if(BT < mod_off[(trk_sep[trk]+i)] + trk_rel[trk]) {_modL = i; break;}\n"
"       \n"
"        for(int _mod = _modL; _mod <= _modU; _mod++)\n"
"        {\n"
"            float B = BT - mod_on[trk_sep[trk]+_mod];\n"
"\n"
"            int ptn = mod_ptn[trk_sep[trk]+_mod];\n"
"            int PLEN = ptn_sep[ptn+1] - ptn_sep[ptn];\n"
"           \n"
"            int _noteU = PLEN-1;\n"
"            for(int i=0; i<PLEN-1; i++) if(B < note_on[(ptn_sep[ptn]+i+1)]) {_noteU = i; break;}\n"
"\n"
"            int _noteL = PLEN-1;\n"
"            for(int i=0; i<PLEN-1; i++) if(B <= note_off[(ptn_sep[ptn]+i)] + trk_rel[trk]) {_noteL = i; break;}\n"
"           \n"
"            for(int _note = _noteL; _note <= _noteU; _note++)\n"
"            {\n"
"                Bon    = note_on[(ptn_sep[ptn]+_note)];\n"
"                Boff   = note_off[(ptn_sep[ptn]+_note)];\n"
"\n"
"                if(trk_syn[trk] == drum_index)\n"
"                {\n"
"                    int Bdrum = int(mod(note_pitch[ptn_sep[ptn]+_note], drum_synths));\n"
"                    float Bvel = note_vel[(ptn_sep[ptn]+_note)] * pow(2.,mod_transp[trk_sep[trk]+_mod]/6.);\n"
"\n"
"                    //0 is for sidechaining - am I doing this right?\n"
"                    if(Bdrum == 0)\n"
"                        r_sidechain = (1. - theta(B-Bon) * exp(-1000.*(B-Bon))) * smoothstep(Bon,Boff,B);\n"
"                    else\n"
"                        d += trk_norm[trk] * AMAYSYN(time, B, Bon, Boff, Bvel, -Bdrum, trk_rel[trk]);\n"
"                }\n"
"                else\n"
"                {\n"
"                    r += trk_norm[trk] * AMAYSYN(time, B, Bon, Boff,\n"
"                                                   note_pitch[(ptn_sep[ptn]+_note)] + mod_transp[trk_sep[trk]+_mod], trk_syn[trk], trk_rel[trk]);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    return s_atan(s_atan(r_sidechain * r + d));\n"
"}\n"
"\n"
"vec2 mainSound(float t)\n"
"{\n"
"    //enhance the stereo feel\n"
"//     return vec2(sin(2.*PI*440.*t));\n"
"//     float stereo_delay = 2e-4;\n"
"    return vec2(-1.+2.*mod(t,1.));\n"
"//     return vec2(mainSynth(t), mainSynth(t-stereo_delay));\n"
"}\n"
"\n"
"\n"
"void main() \n"
"{\n"
"    // Rescale fragment coordinates to match the correct memory\n"
"    vec2 x = gl_FragCoord.xy;\n"
"    \n"
"    // compute time `t` based on the pixel we're about to write\n"
"    // the 512.0 means the texture is 512 pixels across so it's\n"
"    // using a 2 dimensional texture, 512 samples per row\n"
"    float t = iBlockOffset + dot(x, vec2(1.,512.0))/iSampleRate;\n"
"    \n"
"    // Get the 2 values for left and right channels\n"
"    vec2 y = mainSound( t );\n"
"\n"
"    // convert them from -1 to 1 to 0 to 65535\n"
"    vec2 v  = floor((.5+.5*clamp(y,-1.,1.))*65535.);\n"
"\n"
"    // separate them into low and high bytes\n"
"    vec2 vl = floor(mod(v,256.));\n"
"    vec2 vh = floor(v/256.);\n"
"\n"
"    // write them out where \n"
"    // RED   = channel 0 low byte\n"
"    // GREEN = channel 0 high byte\n"
"    // BLUE  = channel 1 low byte\n"
"    // ALPHA = channel 2 high byte\n"
"    gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y)/255.;\n"
"}\n"
"\n"
"\n"
;
#endif
